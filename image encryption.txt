for height in range(int(image_size[1])):\n",
        "                row.append((pix[width,height]))\n",
        "        image_matrix.append(row)\n",
        "    return image_matrix,image_size[0],color"
        "    return image_matrix, image_size[0], image_size[1],color"
      ],
      "execution_count": 0,
      "outputs": []
@@ -207,7 +207,7 @@
        "        for height in range(int(image_size[1])):\n",
        "                row.append((pix[width,height]))\n",
        "        image_matrix.append(row)\n",
        "    return image_matrix,image_size[0]"
        "    return image_matrix, image_size[0], image_size[1],color"
      ],
      "execution_count": 0,
      "outputs": []
@@ -870,12 +870,12 @@
      },
      "source": [
        "def HenonEncryption(imageName,key):\n",
        "    imageMatrix, dimension, color = getImageMatrix(imageName)\n",
        "    imageMatrix, dimensionX, dimensionY, color = getImageMatrix(imageName)\n",
        "    transformationMatrix = genHenonMap(dimension, key)\n",
        "    resultantMatrix = []\n",
        "    for i in range(dimension):\n",
        "    for i in range(dimensionX):\n",
        "        row = []\n",
        "        for j in range(dimension):\n",
        "        for j in range(dimensionY):\n",
        "            try:\n",
        "                if color:\n",
        "                    row.append(tuple([transformationMatrix[i][j] ^ x for x in imageMatrix[i][j]]))\n",
@@ -891,13 +891,13 @@
        "        except:\n",
        "            resultantMatrix = [row]\n",
        "    if color:\n",
        "      im = Image.new(\"RGB\", (dimension, dimension))\n",
        "      im = Image.new(\"RGB\", (dimensionX, dimensionY))\n",
        "    else: \n",
        "      im = Image.new(\"L\", (dimension, dimension)) # L is for Black and white pixels\n",
        "      im = Image.new(\"L\", (dimensionX, dimensionY)) # L is for Black and white pixels\n",
        "\n",
        "    pix = im.load()\n",
        "    for x in range(dimension):\n",
        "        for y in range(dimension):\n",
        "    for x in range(dimensionX):\n",
        "        for y in range(dimensionY):\n",
        "            pix[x, y] = resultantMatrix[x][y]\n",
        "    im.save(imageName.split('.')[0] + \"_HenonEnc.png\", \"PNG\")"
      ],
@@ -923,14 +923,14 @@
      },
      "source": [
        "def HenonDecryption(imageNameEnc, key):\n",
        "    imageMatrix, dimension, color = getImageMatrix(imageNameEnc)\n",
        "    imageMatrix, dimensionX, dimensionY, color = getImageMatrix(imageNameEnc)\n",
        "    transformationMatrix = genHenonMap(dimension, key)\n",
        "    pil_im = Image.open(imageNameEnc, 'r')\n",
        "    imshow(np.asarray(pil_im))\n",
        "    henonDecryptedImage = []\n",
        "    for i in range(dimension):\n",
        "    for i in range(dimensionX):\n",
        "        row = []\n",
        "        for j in range(dimension):\n",
        "        for j in range(dimensionY):\n",
        "            try:\n",
        "                if color:\n",
        "                    row.append(tuple([transformationMatrix[i][j] ^ x for x in imageMatrix[i][j]]))\n",
@@ -946,13 +946,13 @@
        "        except:\n",
        "            henonDecryptedImage = [row]\n",
        "    if color:\n",
        "        im = Image.new(\"RGB\", (dimension, dimension))\n",
        "        im = Image.new(\"RGB\", (dimensionX, dimensionY))\n",
        "    else: \n",
        "        im = Image.new(\"L\", (dimension, dimension)) # L is for Black and white pixels\n",
        "        im = Image.new(\"L\", (dimensionX, dimensionY)) # L is for Black and white pixels\n",
        "\n",
        "    pix = im.load()\n",
        "    for x in range(dimension):\n",
        "        for y in range(dimension):\n",
        "    for x in range(dimensionX):\n",
        "        for y in range(dimensionY):\n",
        "            pix[x, y] = henonDecryptedImage[x][y]\n",
        "    im.save(imageNameEnc.split('_')[0] + \"_HenonDec.png\", \"PNG\")"
      ],
@@ -1682,11 +1682,11 @@
        "    x = 4*(S_x)*(1-S_x)\n",
        "    y = 4*(S_y)*(1-S_y)\n",
        "    \n",
        "    imageMatrix,dimension, color = getImageMatrix(imageName)\n",
        "    imageMatrix,dimensionX, dimensionY, color = getImageMatrix(imageName)\n",
        "    LogisticEncryptionIm = []\n",
        "    for i in range(dimension):\n",
        "    for i in range(dimensionX):\n",
        "        row = []\n",
        "        for j in range(dimension):\n",
        "        for j in range(dimensionY):\n",
        "            while x <0.8 and x > 0.2 :\n",
        "                x = 4*x*(1-x)\n",
        "            while y <0.8 and y > 0.2 :\n",
@@ -1713,15 +1713,15 @@
        "                key_list[12] = key_list[12] ^ key_list[ki]\n",
        "        LogisticEncryptionIm.append(row)\n",
        "\n",
        "    im = Image.new(\"L\", (dimension, dimension))\n",
        "    im = Image.new(\"L\", (dimensionX, dimensionY))\n",
        "    if color:\n",
        "        im = Image.new(\"RGB\", (dimension, dimension))\n",
        "        im = Image.new(\"RGB\", (dimensionX, dimensionY))\n",
        "    else: \n",
        "        im = Image.new(\"L\", (dimension, dimension)) # L is for Black and white pixels\n",
        "        im = Image.new(\"L\", (dimensionX, dimensionY)) # L is for Black and white pixels\n",
        "      \n",
        "    pix = im.load()\n",
        "    for x in range(dimension):\n",
        "        for y in range(dimension):\n",
        "    for x in range(dimensionX):\n",
        "        for y in range(dimensionY):\n",
        "            pix[x, y] = LogisticEncryptionIm[x][y]\n",
        "    im.save(imageName.split('.')[0] + \"_LogisticEnc.png\", \"PNG\")"
      ],
@@ -1776,12 +1776,12 @@
        "    y_prev = 4*(L_x)*(1-S_y)\n",
        "    x = x_prev\n",
        "    y = y_prev\n",
        "    imageMatrix, dimension, color = getImageMatrix(imageName)\n",
        "    imageMatrix,dimensionX, dimensionY, color = getImageMatrix(imageName)\n",
        "\n",
        "    henonDecryptedImage = []\n",
        "    for i in range(dimension):\n",
        "    for i in range(dimensionX):\n",
        "        row = []\n",
        "        for j in range(dimension):\n",
        "        for j in range(dimensionY):\n",
        "            while x <0.8 and x > 0.2 :\n",
        "                x = 4*x*(1-x)\n",
        "            while y <0.8 and y > 0.2 :\n",
@@ -1811,12 +1811,12 @@
        "                key_list[12] = key_list[12] ^ key_list[ki]\n",
        "        henonDecryptedImage.append(row)\n",
        "    if color:\n",
        "        im = Image.new(\"RGB\", (dimension, dimension))\n",
        "        im = Image.new(\"RGB\", (dimensionX, dimensionY))\n",
        "    else: \n",
        "        im = Image.new(\"L\", (dimension, dimension)) # L is for Black and white pixels\n",
        "        im = Image.new(\"L\", (dimensionX, dimensionY)) # L is for Black and white pixels\n",
        "    pix = im.load()\n",
        "    for x in range(dimension):\n",
        "        for y in range(dimension):\n",
        "    for x in range(dimensionX):\n",
        "        for y in range(dimensionY):\n",
        "            pix[x, y] = henonDecryptedImage[x][y]\n",
        "    im.save(imageName.split('_')[0] + \"_LogisticDec.png\", \"PNG\")"
      ],
@@ -1912,6 +1912,8 @@
        }
      },
      "source": [
        "# Note: As it is implemented, the funciton will assume a 13 character long encryption key.\n",
        "#       One can tweak this limitation by changing the \"key_list\" structure at the Logistic functions.\n",
        "LogisticEncryption(\"lena.bmp\", \"abcdefghijklm\")\n",
        "im = Image.open(\"lena_LogisticEnc.png\", 'r')\n",
        "imshow(np.asarray(im), cmap='gray')"
@@ -2885,4 +2887,4 @@
      ]
    }
  ]
}
